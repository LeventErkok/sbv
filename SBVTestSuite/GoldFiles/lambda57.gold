** Calling: z3 -nw -in -smt2
[GOOD] ; Automatically generated by SBV. Do not edit.
[GOOD] (set-option :print-success true)
[GOOD] (set-option :global-declarations true)
[GOOD] (set-option :smtlib2_compliant true)
[GOOD] (set-option :diagnostic-output-channel "stdout")
[GOOD] (set-option :produce-models true)
[GOOD] (set-logic ALL) ; external query, using all logics.
[GOOD] ; --- uninterpreted sorts ---
[GOOD] ; --- tuples ---
[GOOD] ; --- sums ---
[GOOD] ; --- literal constants ---
[GOOD] ; --- top level inputs ---
[GOOD] (declare-fun s0 () (_ BitVec 8))
[GOOD] ; --- constant tables ---
[GOOD] ; --- non-constant tables ---
[GOOD] ; --- arrays ---
[GOOD] ; --- uninterpreted constants ---
[GOOD] ; --- user defined functions ---
[GOOD] ; f1 :: SWord8 -> SWord8, f2 :: SWord8 -> SWord8, f3 :: SWord8 -> SWord8, f4 :: SWord8 -> SWord8
[GOOD] (define-funs-rec
         ((f1 ((l1_s0 (_ BitVec 8))) (_ BitVec 8))
          (f2 ((l2_s0 (_ BitVec 8))) (_ BitVec 8))
          (f3 ((l3_s0 (_ BitVec 8))) (_ BitVec 8))
          (f4 ((l4_s0 (_ BitVec 8))) (_ BitVec 8)))
         (; Definition of: f1 :: SWord8 -> SWord8. [Refers to: f1, f2]
          (let ((l1_s1 #x00))
          (let ((l1_s3 #x01))
          (let ((l1_s6 #x02))
          (let ((l1_s2 (= l1_s0 l1_s1)))
          (let ((l1_s4 (bvsub l1_s0 l1_s3)))
          (let ((l1_s5 (f1 l1_s4)))
          (let ((l1_s7 (bvsub l1_s0 l1_s6)))
          (let ((l1_s8 (f2 l1_s7)))
          (let ((l1_s9 (bvadd l1_s5 l1_s8)))
          (let ((l1_s10 (bvadd l1_s3 l1_s9)))
          (let ((l1_s11 (ite l1_s2 l1_s1 l1_s10)))
          l1_s11)))))))))))
          ; Definition of: f2 :: SWord8 -> SWord8. [Refers to: f2, f3]
          (let ((l2_s1 #x00))
          (let ((l2_s3 #x01))
          (let ((l2_s6 #x02))
          (let ((l2_s2 (= l2_s0 l2_s1)))
          (let ((l2_s4 (bvsub l2_s0 l2_s3)))
          (let ((l2_s5 (f2 l2_s4)))
          (let ((l2_s7 (bvsub l2_s0 l2_s6)))
          (let ((l2_s8 (f3 l2_s7)))
          (let ((l2_s9 (bvadd l2_s5 l2_s8)))
          (let ((l2_s10 (bvadd l2_s3 l2_s9)))
          (let ((l2_s11 (ite l2_s2 l2_s1 l2_s10)))
          l2_s11)))))))))))
          ; Definition of: f3 :: SWord8 -> SWord8. [Refers to: f3, f4]
          (let ((l3_s1 #x00))
          (let ((l3_s3 #x01))
          (let ((l3_s6 #x02))
          (let ((l3_s2 (= l3_s0 l3_s1)))
          (let ((l3_s4 (bvsub l3_s0 l3_s3)))
          (let ((l3_s5 (f3 l3_s4)))
          (let ((l3_s7 (bvsub l3_s0 l3_s6)))
          (let ((l3_s8 (f4 l3_s7)))
          (let ((l3_s9 (bvadd l3_s5 l3_s8)))
          (let ((l3_s10 (bvadd l3_s3 l3_s9)))
          (let ((l3_s11 (ite l3_s2 l3_s1 l3_s10)))
          l3_s11)))))))))))
          ; Definition of: f4 :: SWord8 -> SWord8. [Refers to: f4, f1]
          (let ((l4_s1 #x00))
          (let ((l4_s3 #x01))
          (let ((l4_s6 #x02))
          (let ((l4_s2 (= l4_s0 l4_s1)))
          (let ((l4_s4 (bvsub l4_s0 l4_s3)))
          (let ((l4_s5 (f4 l4_s4)))
          (let ((l4_s7 (bvsub l4_s0 l4_s6)))
          (let ((l4_s8 (f1 l4_s7)))
          (let ((l4_s9 (bvadd l4_s5 l4_s8)))
          (let ((l4_s10 (bvadd l4_s3 l4_s9)))
          (let ((l4_s11 (ite l4_s2 l4_s1 l4_s10)))
          l4_s11)))))))))))))
[GOOD] ; --- assignments ---
[GOOD] (define-fun s1 () (_ BitVec 8) (f1 s0))
[GOOD] (define-fun s2 () Bool (= s0 s1))
[GOOD] ; --- arrayDelayeds ---
[GOOD] ; --- arraySetups ---
[GOOD] ; --- delayedEqualities ---
[GOOD] ; --- formula ---
[GOOD] (assert s2)
[GOOD] (declare-fun s3 () (_ BitVec 8))
[GOOD] (define-fun s4 () (_ BitVec 8) (f1 s3))
[GOOD] (define-fun s5 () Bool (= s3 s4))
[GOOD] (assert s5)
[SEND] (check-sat)
[RECV] sat
[SEND] (get-value (s0))
[RECV] ((s0 #x00))
[SEND] (get-value (s3))
[RECV] ((s3 #x00))
*** Solver   : Z3
*** Exit code: ExitSuccess

RESULT:
  s0 = 0 :: Word8
  s3 = 0 :: Word8
